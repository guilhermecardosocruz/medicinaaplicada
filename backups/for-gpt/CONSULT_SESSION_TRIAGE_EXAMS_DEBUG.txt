
===== prisma/schema.prisma =====
1 generator client {
2   provider = "prisma-client-js"
3 }
4 
5 datasource db {
6   provider  = "postgresql"
7   url       = env("DATABASE_URL")
8   directUrl = env("DIRECT_URL")
9 }
10 
11 model User {
12   id           String   @id @default(cuid())
13   name         String
14   email        String   @unique
15   passwordHash String
16   createdAt    DateTime @default(now())
17   updatedAt    DateTime @updatedAt
18 
19   resetTokens PasswordResetToken[]
20   sessions    ConsultSession[]
21 }
22 
23 model PasswordResetToken {
24   id        String   @id @default(cuid())
25   token     String   @unique
26   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
27   userId    String
28   expiresAt DateTime
29   createdAt DateTime @default(now())
30 }
31 
32 enum ConsultStatus {
33   IN_PROGRESS
34   WAITING_EVAL
35   DONE
36 }
37 
38 enum MessageRole {
39   STUDENT
40   PATIENT_AI
41   COORDINATOR_AI
42   SYSTEM
43 }
44 
45 model Case {
46   id        String   @id @default(cuid())
47   title     String
48   triage    String?
49   seed      String
50   createdAt DateTime @default(now())
51 
52   sessions ConsultSession[]
53 }
54 
55 model ConsultSession {
56   id        String        @id @default(cuid())
57   userId    String
58   caseId    String
59   status    ConsultStatus @default(IN_PROGRESS)
60   createdAt DateTime      @default(now())
61   updatedAt DateTime      @updatedAt
62 
63   user       User @relation(fields: [userId], references: [id], onDelete: Cascade)
64   case       Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
65   messages   Message[]
66   memory     ConsultMemory?
67   evaluation Evaluation?
68 
69   @@index([userId])
70   @@index([caseId])
71 }
72 
73 model Message {
74   id        String      @id @default(cuid())
75   sessionId String
76   role      MessageRole
77   content   String
78   createdAt DateTime    @default(now())
79 
80   session ConsultSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
81 
82   @@index([sessionId])
83   @@index([createdAt])
84 }
85 
86 model ConsultMemory {
87   id        String   @id @default(cuid())
88   sessionId String   @unique
89   summary   String   @default("")
90   facts     Json?
91   turnCount Int      @default(0)
92   updatedAt DateTime @updatedAt
93 
94   session ConsultSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
95 }
96 
97 model Evaluation {
98   id           String   @id @default(cuid())
99   sessionId    String   @unique
100   score        Int
101   strengths    Json?
102   weaknesses   Json?
103   improvements Json?
104   feedback     String
105   createdAt    DateTime @default(now())
106 
107   session ConsultSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
108 }

===== lib/openai.ts =====
1 import OpenAI from "openai";
2 
3 export function getOpenAIClient() {
4   const apiKey = process.env.OPENAI_API_KEY;
5   if (!apiKey) throw new Error("OPENAI_API_KEY não configurada");
6   return new OpenAI({ apiKey });
7 }
8 
9 export function getOpenAIModel() {
10   // Modelo barato e bom para MVP (pode trocar depois via env)
11   return process.env.OPENAI_MODEL || "gpt-4o-mini";
12 }

===== lib/session.ts =====
1 import type { NextRequest } from "next/server";
2 
3 export type SessionUser = {
4   id: string;
5   name: string;
6   email: string;
7 };
8 
9 const SESSION_COOKIE_NAME = "session";
10 const SESSION_MAX_AGE_SECONDS = 60 * 60 * 24 * 7; // 7 dias
11 
12 function decodeSession(raw: string): SessionUser | null {
13   try {
14     const json = Buffer.from(raw, "base64url").toString("utf-8");
15     const data = JSON.parse(json) as Partial<SessionUser>;
16 
17     if (
18       !data ||
19       typeof data.id !== "string" ||
20       typeof data.name !== "string" ||
21       typeof data.email !== "string"
22     ) {
23       return null;
24     }
25 
26     return {
27       id: data.id,
28       name: data.name,
29       email: data.email,
30     };
31   } catch {
32     return null;
33   }
34 }
35 
36 export function getSessionUser(req: NextRequest): SessionUser | null {
37   const cookie = req.cookies.get(SESSION_COOKIE_NAME)?.value;
38   if (!cookie) return null;
39   return decodeSession(cookie);
40 }
41 
42 export function buildSessionCookie(user: SessionUser) {
43   const json = JSON.stringify(user);
44   const token = Buffer.from(json, "utf-8").toString("base64url");
45 
46   return {
47     name: SESSION_COOKIE_NAME,
48     value: token,
49     options: {
50       httpOnly: true,
51       secure: process.env.NODE_ENV === "production",
52       sameSite: "lax" as const,
53       path: "/",
54       maxAge: SESSION_MAX_AGE_SECONDS,
55     },
56   };
57 }

===== lib/prisma.ts =====
1 import { PrismaClient } from "@prisma/client";
2 
3 const globalForPrisma = globalThis as unknown as {
4   prisma: PrismaClient | undefined;
5 };
6 
7 export const prisma =
8   globalForPrisma.prisma ??
9   new PrismaClient({
10     log: ["query", "error", "warn"],
11   });
12 
13 if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

===== lib/validation.ts =====
1 import { z } from "zod";
2 
3 export const passwordSchema = z
4   .string()
5   .min(8, "A senha deve ter no mínimo 8 caracteres")
6   .regex(/[a-z]/, "A senha deve ter pelo menos uma letra minúscula")
7   .regex(/[A-Z]/, "A senha deve ter pelo menos uma letra maiúscula")
8   .regex(/\d/, "A senha deve ter pelo menos um número")
9   .regex(
10     /[^A-Za-z0-9]/,
11     "A senha deve ter pelo menos um caractere especial (!@#$%&*, etc.)"
12   );
13 
14 export const registerSchema = z
15   .object({
16     name: z.string().min(3, "Nome muito curto"),
17     email: z.string().email("E-mail inválido"),
18     password: passwordSchema,
19     confirmPassword: z.string(),
20   })
21   .refine((data) => data.password === data.confirmPassword, {
22     path: ["confirmPassword"],
23     message: "As senhas não conferem",
24   });
25 
26 export const loginSchema = z.object({
27   email: z.string().email("E-mail inválido"),
28   password: z.string().min(1, "Informe sua senha"),
29 });
30 
31 export const recoverSchema = z.object({
32   email: z.string().email("E-mail inválido"),
33 });
34 
35 export const resetSchema = z.object({
36   token: z.string().min(1, "Token inválido"),
37   password: passwordSchema,
38 });

===== app/api/cases/next/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { getSessionUser } from "@/lib/session";
3 import { prisma } from "@/lib/prisma";
4 import { getOpenAIClient, getOpenAIModel } from "@/lib/openai";
5 
6 type CasePayload = {
7   title: string;
8   triage?: string;
9   seed: string;
10 };
11 
12 function safeJsonParse(text: string): unknown {
13   try {
14     return JSON.parse(text);
15   } catch {
16     const start = text.indexOf("{");
17     const end = text.lastIndexOf("}");
18     if (start >= 0 && end > start) {
19       try {
20         return JSON.parse(text.slice(start, end + 1));
21       } catch {
22         return null;
23       }
24     }
25     return null;
26   }
27 }
28 
29 export async function POST(req: NextRequest) {
30   const me = getSessionUser(req);
31   if (!me) return NextResponse.json({ ok: false }, { status: 401 });
32 
33   const openai = getOpenAIClient();
34   const model = getOpenAIModel();
35 
36   const system = `
37 Você é um gerador de casos clínicos para simulação com estudantes de medicina.
38 Retorne APENAS JSON válido, sem markdown, sem texto extra.
39 
40 Regras:
41 - Caso realista, linguagem leiga do paciente.
42 - Não entregue diagnóstico final.
43 - "seed" deve descrever a persona do paciente + contexto + sintomas + histórico curto + sinais de alarme (se houver).
44 - "title" curto (ex: "Dor abdominal e náuseas").
45 - "triage" opcional (ex: "Baixa", "Média", "Alta").
46 Formato:
47 {"title":"...","triage":"...","seed":"..."}
48 `;
49 
50   const completion = await openai.chat.completions.create({
51     model,
52     temperature: 0.7,
53     messages: [
54       { role: "system", content: system.trim() },
55       {
56         role: "user",
57         content:
58           "Gere 1 caso para atendimento ambulatorial (MVP), com sintomas iniciais suficientes para iniciar anamnese.",
59       },
60     ],
61   });
62 
63   const text = completion.choices[0]?.message?.content ?? "";
64   const parsed = safeJsonParse(text) as Partial<CasePayload> | null;
65 
66   if (!parsed || typeof parsed.title !== "string" || typeof parsed.seed !== "string") {
67     return NextResponse.json(
68       { ok: false, message: "Falha ao gerar caso (JSON inválido).", raw: text.slice(0, 500) },
69       { status: 500 },
70     );
71   }
72 
73   const created = await prisma.case.create({
74     data: {
75       title: parsed.title.trim(),
76       triage: typeof parsed.triage === "string" ? parsed.triage.trim() : null,
77       seed: parsed.seed.trim(),
78       sessions: {
79         create: {
80           userId: me.id,
81           status: "IN_PROGRESS",
82           messages: {
83             createMany: {
84               data: [
85                 {
86                   role: "SYSTEM",
87                   content:
88                     "Você iniciou uma consulta simulada. Faça anamnese, explore sintomas, antecedentes, e finalize quando achar adequado.",
89                 },
90               ],
91             },
92           },
93           memory: {
94             create: {
95               summary: "",
96               turnCount: 0,
97               // facts: (não enviar) — evita conflito de tipos do Json no Prisma
98             },
99           },
100         },
101       },
102     },
103     select: {
104       id: true,
105       title: true,
106       triage: true,
107       sessions: { select: { id: true } },
108     },
109   });
110 
111   const sessionId = created.sessions[0]?.id;
112   return NextResponse.json(
113     { ok: true, sessionId, case: { id: created.id, title: created.title, triage: created.triage } },
114     { status: 200 },
115   );
116 }

===== app/api/sessions/my/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { getSessionUser } from "@/lib/session";
3 import { prisma } from "@/lib/prisma";
4 
5 export async function GET(req: NextRequest) {
6   const me = getSessionUser(req);
7   if (!me) return NextResponse.json({ ok: false }, { status: 401 });
8 
9   const items = await prisma.consultSession.findMany({
10     where: { userId: me.id },
11     orderBy: { updatedAt: "desc" },
12     take: 30,
13     select: {
14       id: true,
15       status: true,
16       createdAt: true,
17       updatedAt: true,
18       case: { select: { title: true, triage: true } },
19       evaluation: { select: { score: true } },
20     },
21   });
22 
23   return NextResponse.json({ ok: true, items }, { status: 200 });
24 }

===== app/api/sessions/[id]/messages/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 import { getSessionUser } from "@/lib/session";
4 import { getOpenAIClient, getOpenAIModel } from "@/lib/openai";
5 
6 export async function GET(req: NextRequest, ctx: { params: Promise<{ id: string }> }) {
7   const me = getSessionUser(req);
8   if (!me) return NextResponse.json({ ok: false }, { status: 401 });
9 
10   const { id } = await ctx.params;
11 
12   const session = await prisma.consultSession.findFirst({
13     where: { id, userId: me.id },
14     select: {
15       id: true,
16       status: true,
17       case: { select: { title: true, triage: true } },
18       evaluation: { select: { score: true, feedback: true, strengths: true, weaknesses: true, improvements: true } },
19       messages: { orderBy: { createdAt: "asc" }, select: { id: true, role: true, content: true, createdAt: true } },
20     },
21   });
22 
23   if (!session) return NextResponse.json({ ok: false }, { status: 404 });
24 
25   return NextResponse.json({ ok: true, session }, { status: 200 });
26 }
27 
28 export async function POST(req: NextRequest, ctx: { params: Promise<{ id: string }> }) {
29   const me = getSessionUser(req);
30   if (!me) return NextResponse.json({ ok: false }, { status: 401 });
31 
32   const { id } = await ctx.params;
33 
34   const body = (await req.json().catch(() => null)) as { content?: unknown } | null;
35   const content = typeof body?.content === "string" ? body.content.trim() : "";
36   if (!content) return NextResponse.json({ ok: false, message: "Mensagem vazia." }, { status: 400 });
37 
38   const session = await prisma.consultSession.findFirst({
39     where: { id, userId: me.id },
40     select: {
41       id: true,
42       status: true,
43       case: { select: { seed: true, title: true } },
44       messages: { orderBy: { createdAt: "asc" }, select: { role: true, content: true } },
45     },
46   });
47 
48   if (!session) return NextResponse.json({ ok: false }, { status: 404 });
49   if (session.status !== "IN_PROGRESS") {
50     return NextResponse.json({ ok: false, message: "Sessão não está em andamento." }, { status: 400 });
51   }
52 
53   // grava mensagem do aluno
54   await prisma.message.create({
55     data: { sessionId: session.id, role: "STUDENT", content },
56   });
57 
58   // monta contexto barato: seed + últimas mensagens (janela curta)
59   const last = [...session.messages, { role: "STUDENT" as const, content }].slice(-12);
60 
61   const system = `
62 Você é um PACIENTE simulando um atendimento médico.
63 Você deve responder como paciente humano, linguagem leiga, com emoções e detalhes realistas.
64 Não diga que é IA. Não invente exames ou diagnósticos definitivos.
65 Se o aluno fizer perguntas vagas, peça esclarecimentos.
66 Caso base (persona e contexto):
67 ${session.case.seed}
68 `.trim();
69 
70   const openai = getOpenAIClient();
71   const model = getOpenAIModel();
72 
73   const completion = await openai.chat.completions.create({
74     model,
75     temperature: 0.8,
76     messages: [
77       { role: "system", content: system },
78       ...last.map((m) => ({
79         role: m.role === "STUDENT" ? ("user" as const) : ("assistant" as const),
80         content: m.content,
81       })),
82     ],
83   });
84 
85   const reply = completion.choices[0]?.message?.content?.trim() || "Desculpa, não entendi bem…";
86 
87   await prisma.message.create({
88     data: { sessionId: session.id, role: "PATIENT_AI", content: reply },
89   });
90 
91   // atualiza updatedAt (já acontece) e pronto
92   return NextResponse.json({ ok: true, reply }, { status: 200 });
93 }

===== app/api/sessions/[id]/finalize/route.ts =====
1 import { NextRequest, NextResponse } from "next/server";
2 import { prisma } from "@/lib/prisma";
3 import { getSessionUser } from "@/lib/session";
4 import { getOpenAIClient, getOpenAIModel } from "@/lib/openai";
5 
6 type EvalJson = {
7   score: number;
8   feedback: string;
9   strengths?: string[];
10   weaknesses?: string[];
11   improvements?: string[];
12 };
13 
14 function safeJsonParse(text: string): unknown {
15   try {
16     return JSON.parse(text);
17   } catch {
18     const start = text.indexOf("{");
19     const end = text.lastIndexOf("}");
20     if (start >= 0 && end > start) {
21       try {
22         return JSON.parse(text.slice(start, end + 1));
23       } catch {
24         return null;
25       }
26     }
27     return null;
28   }
29 }
30 
31 export async function POST(req: NextRequest, ctx: { params: Promise<{ id: string }> }) {
32   const me = getSessionUser(req);
33   if (!me) return NextResponse.json({ ok: false }, { status: 401 });
34 
35   const { id } = await ctx.params;
36 
37   const session = await prisma.consultSession.findFirst({
38     where: { id, userId: me.id },
39     select: {
40       id: true,
41       status: true,
42       case: { select: { title: true } },
43       messages: { orderBy: { createdAt: "asc" }, select: { role: true, content: true } },
44       evaluation: { select: { id: true } },
45     },
46   });
47 
48   if (!session) return NextResponse.json({ ok: false }, { status: 404 });
49   if (session.evaluation) return NextResponse.json({ ok: false, message: "Sessão já avaliada." }, { status: 400 });
50 
51   // marca como esperando avaliação (opcional)
52   await prisma.consultSession.update({
53     where: { id: session.id },
54     data: { status: "WAITING_EVAL" },
55   });
56 
57   const transcript = session.messages
58     .map((m) => {
59       const who =
60         m.role === "STUDENT" ? "ALUNO" :
61         m.role === "PATIENT_AI" ? "PACIENTE" :
62         m.role === "COORDINATOR_AI" ? "COORDENADOR" : "SISTEMA";
63       return `${who}: ${m.content}`;
64     })
65     .join("\n");
66 
67   const system = `
68 Você é um COORDENADOR avaliando uma consulta simulada de estudante de medicina.
69 Retorne APENAS JSON válido, sem markdown, sem texto extra.
70 
71 Critérios (nota 0-10):
72 - Acolhimento e comunicação
73 - Anamnese (perguntas relevantes)
74 - Organização do raciocínio
75 - Segurança do paciente (sinais de alarme, orientação responsável)
76 - Encerramento (resumo e próximos passos)
77 
78 Formato:
79 {
80   "score": 0-10,
81   "feedback": "texto curto e objetivo",
82   "strengths": ["..."],
83   "weaknesses": ["..."],
84   "improvements": ["..."]
85 }
86 `.trim();
87 
88   const openai = getOpenAIClient();
89   const model = getOpenAIModel();
90 
91   const completion = await openai.chat.completions.create({
92     model,
93     temperature: 0.3,
94     messages: [
95       { role: "system", content: system },
96       { role: "user", content: `Caso: ${session.case.title}\n\nTranscrição:\n${transcript}` },
97     ],
98   });
99 
100   const text = completion.choices[0]?.message?.content ?? "";
101   const parsed = safeJsonParse(text) as Partial<EvalJson> | null;
102 
103   const scoreRaw = parsed?.score;
104   const score =
105     typeof scoreRaw === "number" && Number.isFinite(scoreRaw)
106       ? Math.max(0, Math.min(10, Math.round(scoreRaw)))
107       : 0;
108 
109   const feedback = typeof parsed?.feedback === "string" ? parsed.feedback.trim() : "Avaliação indisponível.";
110   const strengths = Array.isArray(parsed?.strengths) ? parsed?.strengths.filter((s) => typeof s === "string") : [];
111   const weaknesses = Array.isArray(parsed?.weaknesses) ? parsed?.weaknesses.filter((s) => typeof s === "string") : [];
112   const improvements = Array.isArray(parsed?.improvements) ? parsed?.improvements.filter((s) => typeof s === "string") : [];
113 
114   await prisma.evaluation.create({
115     data: {
116       sessionId: session.id,
117       score,
118       feedback,
119       strengths,
120       weaknesses,
121       improvements,
122     },
123   });
124 
125   await prisma.message.create({
126     data: {
127       sessionId: session.id,
128       role: "COORDINATOR_AI",
129       content: `Nota: ${score}/10\n\n${feedback}`,
130     },
131   });
132 
133   await prisma.consultSession.update({
134     where: { id: session.id },
135     data: { status: "DONE" },
136   });
137 
138   return NextResponse.json({ ok: true, score }, { status: 200 });
139 }

===== app/(app)/consultas/[id]/ConsultClient.tsx =====
1 "use client";
2 
3 import { useEffect, useMemo, useRef, useState } from "react";
4 import { useRouter } from "next/navigation";
5 
6 type Msg = {
7   id: string;
8   role: "STUDENT" | "PATIENT_AI" | "COORDINATOR_AI" | "SYSTEM";
9   content: string;
10   createdAt: string;
11 };
12 
13 type SessionPayload = {
14   id: string;
15   status: "IN_PROGRESS" | "WAITING_EVAL" | "DONE";
16   case: { title: string; triage: string | null };
17   messages: Msg[];
18   evaluation?: {
19     score: number;
20     feedback: string;
21     strengths: unknown;
22     weaknesses: unknown;
23     improvements: unknown;
24   } | null;
25 };
26 
27 export default function ConsultClient({ sessionId }: { sessionId: string }) {
28   const router = useRouter();
29   const [loading, setLoading] = useState(true);
30   const [sending, setSending] = useState(false);
31   const [finalizing, setFinalizing] = useState(false);
32   const [session, setSession] = useState<SessionPayload | null>(null);
33   const [text, setText] = useState("");
34   const bottomRef = useRef<HTMLDivElement | null>(null);
35 
36   async function load() {
37     setLoading(true);
38     try {
39       const res = await fetch(`/api/sessions/${encodeURIComponent(sessionId)}/messages`, { cache: "no-store" });
40       if (!res.ok) {
41         setSession(null);
42         return;
43       }
44       const data = (await res.json()) as { ok: boolean; session: SessionPayload };
45       if (data?.ok) setSession(data.session);
46     } finally {
47       setLoading(false);
48     }
49   }
50 
51   useEffect(() => {
52     void load();
53     // eslint-disable-next-line react-hooks/exhaustive-deps
54   }, [sessionId]);
55 
56   useEffect(() => {
57     bottomRef.current?.scrollIntoView({ behavior: "smooth" });
58   }, [session?.messages?.length]);
59 
60   const title = useMemo(() => session?.case?.title ?? "Consulta", [session]);
61 
62   async function send() {
63     const content = text.trim();
64     if (!content || sending) return;
65     setSending(true);
66     setText("");
67 
68     try {
69       const res = await fetch(`/api/sessions/${encodeURIComponent(sessionId)}/messages`, {
70         method: "POST",
71         headers: { "Content-Type": "application/json" },
72         body: JSON.stringify({ content }),
73       });
74 
75       if (!res.ok) {
76         // restaura texto
77         setText(content);
78         return;
79       }
80 
81       await load();
82     } finally {
83       setSending(false);
84     }
85   }
86 
87   async function finalize() {
88     if (finalizing) return;
89     setFinalizing(true);
90     try {
91       const res = await fetch(`/api/sessions/${encodeURIComponent(sessionId)}/finalize`, { method: "POST" });
92       if (res.ok) await load();
93     } finally {
94       setFinalizing(false);
95     }
96   }
97 
98   if (loading) {
99     return <div className="mx-auto max-w-3xl px-4 py-8 text-sm text-muted">Carregando…</div>;
100   }
101 
102   if (!session) {
103     return (
104       <div className="mx-auto max-w-3xl px-4 py-8">
105         <div className="surface p-4">
106           <div className="text-sm font-semibold">Sessão não encontrada</div>
107           <button
108             className="mt-3 rounded-xl border border-app px-3 py-2 text-xs font-semibold hover:opacity-80"
109             onClick={() => router.push("/dashboard")}
110           >
111             Voltar ao dashboard
112           </button>
113         </div>
114       </div>
115     );
116   }
117 
118   return (
119     <div className="mx-auto max-w-3xl px-4 pb-24 pt-6">
120       <div className="surface-strong p-4">
121         <div className="flex items-start justify-between gap-3">
122           <div>
123             <div className="text-sm font-semibold">{title}</div>
124             <div className="mt-1 text-xs text-muted">
125               Status: {session.status === "IN_PROGRESS" ? "Em andamento" : session.status === "WAITING_EVAL" ? "Avaliando" : "Finalizado"}
126               {session.case.triage ? ` • Triagem: ${session.case.triage}` : ""}
127             </div>
128           </div>
129 
130           {session.status === "IN_PROGRESS" && (
131             <button
132               onClick={finalize}
133               disabled={finalizing}
134               className="rounded-xl border border-app px-3 py-2 text-xs font-semibold hover:opacity-80 disabled:opacity-60"
135             >
136               {finalizing ? "Finalizando…" : "Finalizar atendimento"}
137             </button>
138           )}
139         </div>
140       </div>
141 
142       <div className="mt-4 space-y-3">
143         {session.messages.map((m) => {
144           const isMe = m.role === "STUDENT";
145           const isSystem = m.role === "SYSTEM";
146           const bubble =
147             isSystem
148               ? "surface px-3 py-2 text-xs text-muted"
149               : isMe
150               ? "ml-auto max-w-[85%] rounded-2xl bg-card-strong border border-app px-3 py-2 text-sm"
151               : "mr-auto max-w-[85%] rounded-2xl bg-card border border-app px-3 py-2 text-sm";
152 
153           return (
154             <div key={m.id} className={isSystem ? "" : isMe ? "flex justify-end" : "flex justify-start"}>
155               <div className={bubble} style={{ whiteSpace: "pre-wrap" }}>
156                 {m.content}
157               </div>
158             </div>
159           );
160         })}
161         <div ref={bottomRef} />
162       </div>
163 
164       {session.status === "DONE" && session.evaluation && (
165         <div className="mt-6 surface p-4">
166           <div className="text-sm font-semibold">Avaliação do coordenador</div>
167           <div className="mt-2 text-sm">Nota: <span className="font-semibold">{session.evaluation.score}/10</span></div>
168           <div className="mt-2 text-sm text-muted" style={{ whiteSpace: "pre-wrap" }}>
169             {session.evaluation.feedback}
170           </div>
171         </div>
172       )}
173 
174       {/* Input fixo embaixo */}
175       {session.status === "IN_PROGRESS" && (
176         <div className="fixed inset-x-0 bottom-0 border-t border-[var(--border)] bg-card-strong backdrop-blur">
177           <div className="mx-auto flex max-w-3xl items-center gap-2 px-4 py-3">
178             <input
179               value={text}
180               onChange={(e) => setText(e.target.value)}
181               onKeyDown={(e) => {
182                 if (e.key === "Enter" && !e.shiftKey) {
183                   e.preventDefault();
184                   void send();
185                 }
186               }}
187               placeholder="Digite sua mensagem…"
188               className="input-app w-full rounded-2xl border px-3 py-2 text-sm outline-none"
189               disabled={sending}
190             />
191             <button
192               onClick={() => void send()}
193               disabled={sending || !text.trim()}
194               className="rounded-2xl border border-app px-4 py-2 text-sm font-semibold hover:opacity-80 disabled:opacity-60"
195             >
196               {sending ? "…" : "Enviar"}
197             </button>
198           </div>
199         </div>
200       )}
201     </div>
202   );
203 }

===== app/(app)/consultas/[id]/page.tsx =====
1 import ConsultClient from "./ConsultClient";
2 
3 export default async function ConsultPage(props: { params: Promise<{ id: string }> }) {
4   const { id } = await props.params;
5   return <ConsultClient sessionId={id} />;
6 }

===== lib/auth.ts =====
1 import bcrypt from "bcryptjs";
2 import { prisma } from "@/lib/prisma";
3 
4 export async function registerUser(name: string, email: string, password: string) {
5   const normalizedEmail = email.toLowerCase();
6 
7   const existing = await prisma.user.findUnique({
8     where: { email: normalizedEmail },
9   });
10 
11   if (existing) {
12     throw new Error("E-mail já cadastrado");
13   }
14 
15   const passwordHash = await bcrypt.hash(password, 10);
16 
17   const user = await prisma.user.create({
18     data: {
19       name,
20       email: normalizedEmail,
21       passwordHash,
22     },
23     select: {
24       id: true,
25       name: true,
26       email: true,
27     },
28   });
29 
30   return user;
31 }
32 
33 export async function validateLogin(email: string, password: string) {
34   const normalizedEmail = email.toLowerCase();
35 
36   const user = await prisma.user.findUnique({
37     where: { email: normalizedEmail },
38   });
39 
40   if (!user) return null;
41 
42   const ok = await bcrypt.compare(password, user.passwordHash);
43   if (!ok) return null;
44 
45   return {
46     id: user.id,
47     name: user.name,
48     email: user.email,
49   };
50 }
51 
52 export async function createResetToken(email: string) {
53   const normalizedEmail = email.toLowerCase();
54 
55   const user = await prisma.user.findUnique({
56     where: { email: normalizedEmail },
57   });
58 
59   if (!user) {
60     // em produção, não revelamos se o e-mail existe
61     return null;
62   }
63 
64   const token = crypto.randomUUID();
65   const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hora
66 
67   await prisma.passwordResetToken.create({
68     data: {
69       token,
70       userId: user.id,
71       expiresAt,
72     },
73   });
74 
75   return token;
76 }
77 
78 export async function resetPassword(token: string, newPassword: string) {
79   const reset = await prisma.passwordResetToken.findUnique({
80     where: { token },
81     include: { user: true },
82   });
83 
84   if (!reset) {
85     throw new Error("Token inválido ou expirado");
86   }
87 
88   if (reset.expiresAt < new Date()) {
89     await prisma.passwordResetToken.delete({
90       where: { token },
91     });
92     throw new Error("Token expirado");
93   }
94 
95   const passwordHash = await bcrypt.hash(newPassword, 10);
96 
97   const updatedUser = await prisma.user.update({
98     where: { id: reset.userId },
99     data: { passwordHash },
100     select: {
101       id: true,
102       email: true,
103     },
104   });
105 
106   await prisma.passwordResetToken.delete({
107     where: { token },
108   });
109 
110   return updatedUser;
111 }

===== middleware.ts =====
1 import { NextResponse, type NextRequest } from "next/server";
2 
3 const SESSION_COOKIE_NAME = "session";
4 
5 // Rotas públicas (não exigir login)
6 const PUBLIC_PREFIXES = [
7   "/login",
8   "/register",
9   "/recover",
10   "/reset",
11   "/api/auth",
12   "/_next",
13   "/favicon.ico",
14   "/manifest.webmanifest",
15   "/sw.js",
16   "/icons",
17   "/public",
18 ];
19 
20 function isPublicPath(pathname: string) {
21   return PUBLIC_PREFIXES.some((p) => pathname === p || pathname.startsWith(p + "/"));
22 }
23 
24 export function middleware(req: NextRequest) {
25   const { pathname, search } = req.nextUrl;
26 
27   // ignora rotas públicas
28   if (isPublicPath(pathname)) return NextResponse.next();
29 
30   // permite APIs (exceto as de auth já estão liberadas acima)
31   if (pathname.startsWith("/api")) return NextResponse.next();
32 
33   // regra: qualquer rota "do app" deve exigir sessão
34   // (neste MVP, vamos exigir sessão para tudo fora do auth)
35   const session = req.cookies.get(SESSION_COOKIE_NAME)?.value;
36 
37   if (!session) {
38     const loginUrl = req.nextUrl.clone();
39     loginUrl.pathname = "/login";
40     loginUrl.searchParams.set("next", pathname + (search ?? ""));
41     return NextResponse.redirect(loginUrl);
42   }
43 
44   return NextResponse.next();
45 }
46 
47 export const config = {
48   matcher: ["/((?!_next/static|_next/image).*)"],
49 };
